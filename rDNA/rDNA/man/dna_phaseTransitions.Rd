% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dna_phaseTransitions.R
\name{dna_phaseTransitions}
\alias{dna_phaseTransitions}
\alias{print.dna_phaseTransitions}
\alias{autoplot.dna_phaseTransitions}
\title{Detect phase transitions and states in a discourse network}
\usage{
dna_phaseTransitions(
  distanceMethod = "absdiff",
  clusterMethods = c("single", "average", "complete", "ward", "kmeans", "pam",
    "spectral", "fastgreedy", "walktrap"),
  k.min = 2,
  k.max = 6,
  cores = 1,
  networkType = "twomode",
  statementType = "DNA Statement",
  variable1 = "organization",
  variable1Document = FALSE,
  variable2 = "concept",
  variable2Document = FALSE,
  qualifier = "agreement",
  qualifierDocument = FALSE,
  qualifierAggregation = "subtract",
  normalization = "no",
  duplicates = "document",
  start.date = "01.01.1900",
  stop.date = "31.12.2099",
  start.time = "00:00:00",
  stop.time = "23:59:59",
  timeWindow = "days",
  windowSize = 200,
  kernel = "uniform",
  normalizeToOne = TRUE,
  indentTime = FALSE,
  excludeValues = list(),
  excludeAuthors = character(),
  excludeSources = character(),
  excludeSections = character(),
  excludeTypes = character(),
  invertValues = FALSE,
  invertAuthors = FALSE,
  invertSources = FALSE,
  invertSections = FALSE,
  invertTypes = FALSE
)

\method{print}{dna_phaseTransitions}(x, ...)

\method{autoplot}{dna_phaseTransitions}(object, ..., plots = c("heatmap", "silhouette", "mds", "states"))
}
\arguments{
\item{distanceMethod}{The distance measure that expresses the dissimilarity
between any two network matrices. The following choices are available:
\itemize{
  \item \code{"absdiff"}: The sum of the cell-wise absolute differences
    between the two matrices, i.e., the sum of differences in edge weights.
    This is equivalent to the graph edit distance because the network
    dimensions are kept constant across all networks by including all nodes
    at all time points (i.e., by including isolates).
  \item \code{"spectral"}: The Euclidean distance between the normalized
    eigenvalues of the graph Laplacian matrices, also called the spectral
    distance between two network matrices. Any negative values (e.g., from
    the subtract method) are replaced by zero before computing the
    distance.
}}

\item{clusterMethods}{The clustering techniques that are applied to the
distance matrix in the end. Hierarchical methods are repeatedly cut off at
different levels, and solutions are compared using network modularity to
pick the best-fitting cluster membership vector. Some of the methods are
slower than others, hence they are not included by default. It is possible
to include any number of methods in the argument. For each included method,
the cluster membership vector (i.e., the states over time) along with the
associated time stamps of the networks are returned, and the modularity of
each included method is computed for comparison. The following methods are
available:
\itemize{
  \item \code{"single"}: Hierarchical clustering with single linkage using
    the \code{\link[stats]{hclust}} function from the \pkg{stats} package.
  \item \code{"average"}: Hierarchical clustering with average linkage
    using the \code{\link[stats]{hclust}} function from the \pkg{stats}
    package.
  \item \code{"complete"}: Hierarchical clustering with complete linkage
    using the \code{\link[stats]{hclust}} function from the \pkg{stats}
    package.
  \item \code{"ward"}: Hierarchical clustering with Ward's method (D2)
    using the \code{\link[stats]{hclust}} function from the \pkg{stats}
    package.
  \item \code{"kmeans"}: k-means clustering using the
    \code{\link[stats]{kmeans}} function from the \pkg{stats} package.
  \item \code{"pam"}: Partitioning around medoids using the
    \code{\link[cluster]{pam}} function from the \pkg{cluster} package.
  \item \code{"spectral"}: Spectral clustering. An affinity matrix using a
    Gaussian (RBF) kernel is created. The Laplacian matrix of the affinity
    matrix is computed and normalized. The first first k eigenvectors of
    the normalized Laplacian matrix are clustered using k-means.
  \item \code{"concor"}: CONvergence of iterative CORrelations (CONCOR)
    with exactly \code{k = 2} clusters. (Not included by default because of
    the limit to \code{k = 2}.)
  \item \code{"fastgreedy"}: Fast & greedy community detection using the
    \code{\link[igraph]{cluster_fast_greedy}} function in the \pkg{igraph}
    package.
  \item \code{"walktrap"}: Walktrap community detection using the
    \code{\link[igraph]{cluster_walktrap}} function in the \pkg{igraph}
    package.
  \item \code{"leading_eigen"}: Leading eigenvector community detection
    using the \code{\link[igraph]{cluster_leading_eigen}} function in the
    \pkg{igraph} package. (Can be slow, hence not included by default.)
  \item \code{"edge_betweenness"}: Girvan-Newman edge betweenness community
    detection using the \code{\link[igraph]{cluster_edge_betweenness}}
    function in the \pkg{igraph} package. (Can be slow, hence not included
    by default.)
}}

\item{k.min}{For the hierarchical cluster methods, how many clusters or
states should at least be identified? Only the best solution between
\code{k.min} and \code{k.max} clusters is retained and compared to other
methods.}

\item{k.max}{For the hierarchical cluster methods, up to how many clusters or
states should be identified? Only the best solution between \code{k.min}
and \code{k.max} clusters is retained and compared to other methods.}

\item{cores}{The number of computing cores for parallel processing. If
\code{1} (the default), no parallel processing is used. If a larger number,
the \pkg{pbmcapply} package is used to parallelize the clustering. Note
that this method is based on forking and is only available on Unix
operating systems, including MacOS and Linux. Note also that the remaining
computations, including the computation of the distance matrix and the
time window network generation with kernel smoothing, are done in parallel
using threads in Java, irrespective of this setting, using as many parallel
threads as cores are available on the system.}

\item{networkType}{The kind of network to be computed. Can be
\code{"twomode"}, \code{"onemode"}, or \code{"eventlist"}.}

\item{statementType}{The name of the statement type in which the variable
of interest is nested. For example, \code{"DNA Statement"}.}

\item{variable1}{The first variable for network construction. In a one-mode
network, this is the variable for both the rows and columns. In a
two-mode network, this is the variable for the rows only. In an event
list, this variable is only used to check for duplicates (depending on
the setting of the \code{duplicates} argument).}

\item{variable1Document}{A boolean value indicating whether the first
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}).}

\item{variable2}{The second variable for network construction. In a one-mode
network, this is the variable over which the ties are created. For
example, if an organization x organization network is created, and ties
in this network indicate co-reference to a concept, then the second
variable is the \code{"concept"}. In a two-mode network, this is the
variable used for the columns of the network matrix. In an event list,
this variable is only used to check for duplicates (depending on the
setting of the \code{duplicates} argument).}

\item{variable2Document}{A boolean value indicating whether the second
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}}

\item{qualifier}{The qualifier variable. In a one-mode network, this
  variable can be used to count only congruence or conflict ties. For
  example, in an organization x organization network via common concepts,
  a binary \code{"agreement"} qualifier could be used to record only ties
  where both organizations have a positive stance on the concept or where
  both organizations have a negative stance on the concept. With an
  integer qualifier, the tie weight between the organizations would be
  proportional to the similarity or distance between the two organizations
  on the scale of the integer variable. With a short text variable as a
  qualifier, agreement on common categorical values of the qualifier is
  required, for example a tie is established (or a tie weight increased) if
  two actors both refer to the same value on the second variable AND match on
  the categorical qualifier, for example the type of referral.

  In a two-mode network, the qualifier variable can be used to retain only
  positive or only negative statements or subtract negative from positive
  mentions. All of this depends on the setting of the
  \code{qualifierAggregation} argument. For event lists, the qualifier
  variable is only used for filtering out duplicates (depending on the
  setting of the \code{duplicates} argument.

  The qualifier can also be \code{NULL}, in which case it is ignored, meaning
  that values in \code{variable1} and \code{variable2} are unconditionally
  associated with each other in the network when they co-occur. This is
  identical to selecting a qualifier variable and setting
  \code{qualifierAggregation = "ignore"}.}

\item{qualifierDocument}{A boolean value indicating whether the qualifier
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}}

\item{qualifierAggregation}{The aggregation rule for the \code{qualifier}
  variable. In one-mode networks, this must be \code{"ignore"} (for
  ignoring the qualifier variable), \code{"congruence"} (for recording a
  network tie only if both nodes have the same qualifier value in the
  binary case or for recording the similarity between the two nodes on the
  qualifier variable in the integer case), \code{"conflict"} (for
  recording a network tie only if both nodes have a different qualifier
  value in the binary case or for recording the distance between the two
  nodes on the qualifier variable in the integer case), or
\code{"subtract"} (for subtracting the conflict tie value from the
  congruence tie value in each dyad). In two-mode networks, this must be
\code{"ignore"}, \code{"combine"} (for creating multiplex combinations,
  e.g., 1 for positive, 2 for negative, and 3 for mixed), or
\code{subtract} (for subtracting negative from positive ties). In event
  lists, this setting is ignored.}

\item{normalization}{Normalization of edge weights. Valid settings for
one-mode networks are \code{"no"} (for switching off normalization),
\code{"average"} (for average activity normalization), \code{"jaccard"}
(for Jaccard coefficient normalization), and \code{"cosine"} (for
cosine similarity normalization). Valid settings for two-mode networks
are \code{"no"}, \code{"activity"} (for activity normalization), and
\code{"prominence"} (for prominence normalization).}

\item{duplicates}{Setting for excluding duplicate statements before network
construction. Valid settings are \code{"include"} (for including all
statements in network construction), \code{"document"} (for counting
only one identical statement per document), \code{"week"} (for counting
only one identical statement per calendar week), \code{"month"} (for
counting only one identical statement per calendar month), \code{"year"}
(for counting only one identical statement per calendar year), and
\code{"acrossrange"} (for counting only one identical statement across
the whole time range).}

\item{start.date}{The start date for network construction in the format
\code{"dd.mm.yyyy"}. All statements before this date will be excluded.}

\item{stop.date}{The stop date for network construction in the format
\code{"dd.mm.yyyy"}. All statements after this date will be excluded.}

\item{start.time}{The start time for network construction on the specified
\code{start.date}. All statements before this time on the specified date
will be excluded.}

\item{stop.time}{The stop time for network construction on the specified
\code{stop.date}. All statements after this time on the specified date
will be excluded.}

\item{timeWindow}{Possible values are \code{"no"}, \code{"events"},
\code{"seconds"}, \code{"minutes"}, \code{"hours"}, \code{"days"},
\code{"weeks"}, \code{"months"}, and \code{"years"}. If \code{"no"} is
selected (= the default setting), no time window will be used. If any of
the time units is selected, a moving time window will be imposed, and
only the statements falling within the time period defined by the window
will be used to create the network. The time window will then be moved
forward by one time unit at a time, and a new network with the new time
boundaries will be created. This is repeated until the end of the overall
time span is reached. All time windows will be saved as separate
networks in a list. The duration of each time window is defined by the
\code{windowSize} argument. For example, this could be used to create a
time window of 6 months which moves forward by one month each time, thus
creating time windows that overlap by five months. If \code{"events"} is
used instead of a natural time unit, the time window will comprise
exactly as many statements as defined in the \code{windowSize} argument.
However, if the start or end statement falls on a date and time where
multiple events happen, those additional events that occur simultaneously
are included because there is no other way to decide which of the
statements should be selected. Therefore the window size is sometimes
extended when the start or end point of a time window is ambiguous in
event time.}

\item{windowSize}{The number of time units of which a moving time window is
comprised. This can be the number of statement events, the number of days
etc., as defined in the \code{"timeWindow"} argument.}

\item{kernel}{Use kernel smoothing for computing network time slices? Several
kernel smoothing functions are available, similar to kernel density
estimation. They down-weight statements the farther they are temporally
away from the temporal mid-point of the respective time slice. Valid
settings are:
\itemize{
  \item \code{"uniform"}: Weight all statements within a time window
    equally with a value of \code{0.5}.
  \item \code{"triangular"}: Use a triangular kernel function.
  \item \code{"epanechnikov"}: Use an Epanechnikov kernel smoother.
  \item \code{"gaussian"}: Use a standard normal distribution as a kernel
    smoother.
  \item \code{"no"}: Circumvent kernel smoothing and weight all statements
    with a value of \code{1.0}. This is a legacy setting and is slow and
    may not return the same results as \code{"uniform"} due to the way it
    was written up.
}}

\item{normalizeToOne}{Divide all cells by the sum of all cells before
computing the dissimilarity between two network matrices? This
normalization scales all edge weights to a sum of \code{1.0}. Doing so can
make networks more comparable by boosting the edge weights of networks that
are relatively sparsely populated by concepts, for example at the beginning
or end of the debate. Note that this normalization should not make any
difference with Euclidean spectral distances of the graph Laplacian because
the eigenvalues are normalized to sum to one in this distance method.}

\item{indentTime}{If \code{TRUE}, the sequence of time slices under the time
window algorithm starts with the first network and ends with the last
network that are entirely covered within the timeline defined by the start
and stop dates and times. For example, if the start date is 1 February, the
stop date is 31 December, and the time window duration is 21 days, the
mid-point of the first time window will be 11 February (to ensure the first
network entirely fits into the timeline), and the last network will be
centered around 20 December (to ensure the last network entirely fits into
the timeline). If \code{FALSE}, the start and stop dates and times are used
as the first and last mid-points. In that case, the first and last few
networks may contain fewer statements than other time slices and may,
therefore, be more similar to each other. This can potentially be
counter-acted by setting the \code{normalizeToOne} argument.}

\item{excludeValues}{A list of named character vectors that contains entries
which should be excluded during network construction. For example,
\code{list(concept = c("A", "B"), organization = c("org A", "org B"))}
would exclude all statements containing concepts "A" or "B" or
organizations "org A" or "org B" when the network is constructed. This
is irrespective of whether these values appear in \code{variable1},
\code{variable2}, or the \code{qualifier}. Note that only variables at
the statement level can be used here. There are separate arguments for
excluding statements nested in documents with certain meta-data.}

\item{excludeAuthors}{A character vector of authors. If a statement is
nested in a document where one of these authors is set in the "Author"
meta-data field, the statement is excluded from network construction.}

\item{excludeSources}{A character vector of sources. If a statement is
nested in a document where one of these sources is set in the "Source"
meta-data field, the statement is excluded from network construction.}

\item{excludeSections}{A character vector of sections. If a statement is
nested in a document where one of these sections is set in the "Section"
meta-data field, the statement is excluded from network construction.}

\item{excludeTypes}{A character vector of types. If a statement is
nested in a document where one of these types is set in the "Type"
meta-data field, the statement is excluded from network construction.}

\item{invertValues}{A boolean value indicating whether the entries provided
by the \code{excludeValues} argument should be excluded from network
construction (\code{invertValues = FALSE}) or if they should be the only
values that should be included during network construction
(\code{invertValues = TRUE}).}

\item{invertAuthors}{A boolean value indicating whether the entries provided
by the \code{excludeAuthors} argument should be excluded from network
construction (\code{invertAuthors = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertAuthors = TRUE}).}

\item{invertSources}{A boolean value indicating whether the entries provided
by the \code{excludeSources} argument should be excluded from network
construction (\code{invertSources = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertSources = TRUE}).}

\item{invertSections}{A boolean value indicating whether the entries
provided by the \code{excludeSections} argument should be excluded from
network construction (\code{invertSections = FALSE}) or if they should
be the only values that should be included during network construction
(\code{invertSections = TRUE}).}

\item{invertTypes}{A boolean value indicating whether the entries provided
by the \code{excludeTypes} argument should be excluded from network
construction (\code{invertTypes = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertTypes = TRUE}).}

\item{x}{A \code{dna_phaseTransitions} object.}

\item{...}{Additional arguments. Currently not in use.}

\item{object}{A \code{"dna_phaseTransitions"} object.}

\item{plots}{The plots to include in the output list. Can be one or more of
the following: \code{"heatmap"}, \code{"silhouette"}, \code{"mds"},
\code{"states"}.}
}
\description{
Detect phase transitions and states in a discourse network.

Show details of a \code{dna_phaseTransitions} object.
}
\details{
This function applies the state dynamics methods of Masuda and Holme to a
time window discourse network. It computes temporally overlapping discourse
networks, computes the dissimilarity between all networks, and clusters them.
For the dissimilarity, the sum of absolute edge weight differences and the
Euclidean spectral distance are available. Several clustering techniques can
be applied to identify the different stages and phases from the resulting
distance matrix.

The function offers kernel smoothing, which means the farther away from a
time point a statement is, the less important it becomes for the network that
is created around the time point. Several kernel smoothing functions are
available; see the \code{kernel} argument.

Print a summary of a \code{dna_phaseTransitions} object, which can be created
using the \link{dna_phaseTransitions} function.
}
\examples{
\dontrun{
library("ggplot2")
dna_init()
dna_sample()
dna_openDatabase("sample.dna", coderId = 1, coderPassword = "sample")

# compute states and phases for sample dataset
results <- dna_phaseTransitions(distanceMethod = "spectral",
                                clusterMethods = c("ward",
                                                   "pam",
                                                   "concor",
                                                   "walktrap"),
                                k.min = 2,
                                k.max = 6,
                                networkType = "onemode",
                                variable1 = "organization",
                                variable2 = "concept",
                                timeWindow = "days",
                                windowSize = 15,
                                kernel = "gaussian",
                                indentTime = FALSE,
                                normalizeToOne = FALSE)
results
autoplot(results)

# access individual plots
plots <- autoplot(results)
plots[[1]] # show heatmap
plots[[2]] # show cluster silhouettes
plots[[3]] # show temporal embedding
plots[[4]] # show state dynamics

# save plots to combined PDF
library("ggplotify") # needed to convert heatmap to ggplot diagram
library("patchwork") # needed to merge plots into 4 x 4 diagram
p1 <- ggplotify::as.ggplot(plots[[1]])
p <- p1 + plots[[2]] + plots[[3]] + plots[[4]] + plot_layout(ncol = 2)
ggsave(filename = "phase_transitions.pdf", p, width = 14, height = 12)
}

}
\author{
Philip Leifeld

Philip Leifeld, Kristijan Garic
}
