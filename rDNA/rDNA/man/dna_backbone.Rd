% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rDNA.R
\name{dna_backbone}
\alias{dna_backbone}
\alias{print.dna_backbone}
\alias{plot.dna_backbone}
\alias{autoplot.dna_backbone}
\alias{dna_evaluateBackboneSolution}
\title{Compute and retrieve the backbone and redundant set}
\usage{
dna_backbone(
  method = "nested",
  backboneSize = 1,
  penalty = 3.5,
  iterations = 10000,
  statementType = "DNA Statement",
  variable1 = "organization",
  variable1Document = FALSE,
  variable2 = "concept",
  variable2Document = FALSE,
  qualifier = "agreement",
  qualifierDocument = FALSE,
  qualifierAggregation = "subtract",
  normalization = "average",
  duplicates = "document",
  start.date = "01.01.1900",
  stop.date = "31.12.2099",
  start.time = "00:00:00",
  stop.time = "23:59:59",
  excludeValues = list(),
  excludeAuthors = character(),
  excludeSources = character(),
  excludeSections = character(),
  excludeTypes = character(),
  invertValues = FALSE,
  invertAuthors = FALSE,
  invertSources = FALSE,
  invertSections = FALSE,
  invertTypes = FALSE,
  fileFormat = NULL,
  outfile = NULL
)

\method{print}{dna_backbone}(x, trim = 50, ...)

\method{plot}{dna_backbone}(x, ma = 500, ...)

\method{autoplot}{dna_backbone}(object, ..., ma = 500)

dna_evaluateBackboneSolution(
  backboneEntities,
  p = 0,
  statementType = "DNA Statement",
  variable1 = "organization",
  variable1Document = FALSE,
  variable2 = "concept",
  variable2Document = FALSE,
  qualifier = "agreement",
  qualifierDocument = FALSE,
  qualifierAggregation = "subtract",
  normalization = "average",
  duplicates = "document",
  start.date = "01.01.1900",
  stop.date = "31.12.2099",
  start.time = "00:00:00",
  stop.time = "23:59:59",
  excludeValues = list(),
  excludeAuthors = character(),
  excludeSources = character(),
  excludeSections = character(),
  excludeTypes = character(),
  invertValues = FALSE,
  invertAuthors = FALSE,
  invertSources = FALSE,
  invertSections = FALSE,
  invertTypes = FALSE
)
}
\arguments{
\item{method}{The backbone algorithm used to compute the results. Several
methods are available:
\itemize{
  \item \code{"nested"}: A relatively fast, deterministic algorithm that
    produces the full hierarchy of entities. It starts with a complete
    backbone set resembling the full network. There are as many iterations
    as entities on the second mode. In each iteration, the entity whose
    removal would yield the smallest backbone loss is moved from the
    backbone set into the redundant set, and the (unpenalized) spectral
    loss is recorded. This creates a solution for all backbone sizes, where
    each backbone set is fully nested in the next larger backbone set. The
    solution usually resembles an unconstrained solution where nesting is
    not required, but in some cases the loss of a non-nested solution may be
    larger at a given level or number of elements in the backbone set.
  \item \code{"fixed"}: Simulated annealing with a fixed number of elements
    in the backbone set (i.e., only lateral changes are possible) and
    without penalty. This method may yield more optimal solutions than the
    nested algorithm because it does not require a strict hierarchy.
    However, it produces an approximation of the global optimum and is
    slower than the nested method. With this method, you can specify that
    backbone set should have, for example, exactly 10 concepts. Then fewer
    iterations are necessary than with the penalty method because the search
    space is smaller. The backbone set size is defined in the
    \code{"backboneSize"} argument.
  \item \code{"penalty"}: Simulated annealing with a variable number of
    elements in the backbone set. The solution is stabilized by a penalty
    parameter (see \code{"penalty"} argument). This algorithm takes longest
    to compute for a single solution, and it is only an approximation, but
    it considers slightly larger or smaller backbone sets if the solution is
    better, thus this algorithm adds some flexibility. It requires more
    iterations than the fixed method for achieving the same quality.
}}

\item{backboneSize}{The number of elements in the backbone set, as a fixed
parameter. Only used when \code{method = "fixed"}.}

\item{penalty}{The penalty parameter for large backbone sets. The larger the
value, the more strongly larger backbone sets are punished and the smaller
the resulting backbone is. Try out different values to find the right size
of the backbone set. Reasonable values could be \code{2.5}, \code{5},
\code{7.5}, or \code{12}, for example. The minimum is \code{0.0}, which
imposes no penalty on the size of the backbone set and produces a redundant
set with only one element. Start with \code{0.0} if you want to weed out a
single concept and subsequently increase the penalty to include more items
in the redundant set and shrink the backbone further. Only used when
\code{method = "penalty"}.}

\item{iterations}{The number of iterations of the simulated annealing
algorithm. More iterations take more time but may lead to better
optimization results. Only used when \code{method = "penalty"} or
\code{method = "fixed"}.}

\item{statementType}{The name of the statement type in which the variable
of interest is nested. For example, \code{"DNA Statement"}.}

\item{variable1}{The first variable for network construction. In a one-mode
network, this is the variable for both the rows and columns. In a
two-mode network, this is the variable for the rows only. In an event
list, this variable is only used to check for duplicates (depending on
the setting of the \code{duplicates} argument).}

\item{variable1Document}{A boolean value indicating whether the first
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}).}

\item{variable2}{The second variable for network construction. In a one-mode
network, this is the variable over which the ties are created. For
example, if an organization x organization network is created, and ties
in this network indicate co-reference to a concept, then the second
variable is the \code{"concept"}. In a two-mode network, this is the
variable used for the columns of the network matrix. In an event list,
this variable is only used to check for duplicates (depending on the
setting of the \code{duplicates} argument).}

\item{variable2Document}{A boolean value indicating whether the second
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}}

\item{qualifier}{The qualifier variable. In a one-mode network, this
  variable can be used to count only congruence or conflict ties. For
  example, in an organization x organization network via common concepts,
  a binary \code{"agreement"} qualifier could be used to record only ties
  where both organizations have a positive stance on the concept or where
  both organizations have a negative stance on the concept. With an
  integer qualifier, the tie weight between the organizations would be
  proportional to the similarity or distance between the two organizations
  on the scale of the integer variable. With a short text variable as a
  qualifier, agreement on common categorical values of the qualifier is
  required, for example a tie is established (or a tie weight increased) if
  two actors both refer to the same value on the second variable AND match on
  the categorical qualifier, for example the type of referral.

  In a two-mode network, the qualifier variable can be used to retain only
  positive or only negative statements or subtract negative from positive
  mentions. All of this depends on the setting of the
  \code{qualifierAggregation} argument. For event lists, the qualifier
  variable is only used for filtering out duplicates (depending on the
  setting of the \code{duplicates} argument.

  The qualifier can also be \code{NULL}, in which case it is ignored, meaning
  that values in \code{variable1} and \code{variable2} are unconditionally
  associated with each other in the network when they co-occur. This is
  identical to selecting a qualifier variable and setting
  \code{qualifierAggregation = "ignore"}.}

\item{qualifierDocument}{A boolean value indicating whether the qualifier
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}}

\item{qualifierAggregation}{The aggregation rule for the \code{qualifier}
variable. This must be \code{"ignore"} (for ignoring the qualifier
variable), \code{"congruence"} (for recording a network tie only if both
nodes have the same qualifier value in the binary case or for recording the
similarity between the two nodes on the qualifier variable in the integer
case), \code{"conflict"} (for recording a network tie only if both nodes
have a different qualifier value in the binary case or for recording the
distance between the two nodes on the qualifier variable in the integer
case), or \code{"subtract"} (for subtracting the conflict tie value from
the congruence tie value in each dyad; note that negative values will be
replaced by \code{0} in the backbone calculation).}

\item{normalization}{Normalization of edge weights. Valid settings are
\code{"no"} (for switching off normalization), \code{"average"} (for
average activity normalization), \code{"jaccard"} (for Jaccard coefficient
normalization), and \code{"cosine"} (for cosine similarity normalization).}

\item{duplicates}{Setting for excluding duplicate statements before network
construction. Valid settings are \code{"include"} (for including all
statements in network construction), \code{"document"} (for counting
only one identical statement per document), \code{"week"} (for counting
only one identical statement per calendar week), \code{"month"} (for
counting only one identical statement per calendar month), \code{"year"}
(for counting only one identical statement per calendar year), and
\code{"acrossrange"} (for counting only one identical statement across
the whole time range).}

\item{start.date}{The start date for network construction in the format
\code{"dd.mm.yyyy"}. All statements before this date will be excluded.}

\item{stop.date}{The stop date for network construction in the format
\code{"dd.mm.yyyy"}. All statements after this date will be excluded.}

\item{start.time}{The start time for network construction on the specified
\code{start.date}. All statements before this time on the specified date
will be excluded.}

\item{stop.time}{The stop time for network construction on the specified
\code{stop.date}. All statements after this time on the specified date
will be excluded.}

\item{excludeValues}{A list of named character vectors that contains entries
which should be excluded during network construction. For example,
\code{list(concept = c("A", "B"), organization = c("org A", "org B"))}
would exclude all statements containing concepts "A" or "B" or
organizations "org A" or "org B" when the network is constructed. This
is irrespective of whether these values appear in \code{variable1},
\code{variable2}, or the \code{qualifier}. Note that only variables at
the statement level can be used here. There are separate arguments for
excluding statements nested in documents with certain meta-data.}

\item{excludeAuthors}{A character vector of authors. If a statement is
nested in a document where one of these authors is set in the "Author"
meta-data field, the statement is excluded from network construction.}

\item{excludeSources}{A character vector of sources. If a statement is
nested in a document where one of these sources is set in the "Source"
meta-data field, the statement is excluded from network construction.}

\item{excludeSections}{A character vector of sections. If a statement is
nested in a document where one of these sections is set in the "Section"
meta-data field, the statement is excluded from network construction.}

\item{excludeTypes}{A character vector of types. If a statement is
nested in a document where one of these types is set in the "Type"
meta-data field, the statement is excluded from network construction.}

\item{invertValues}{A boolean value indicating whether the entries provided
by the \code{excludeValues} argument should be excluded from network
construction (\code{invertValues = FALSE}) or if they should be the only
values that should be included during network construction
(\code{invertValues = TRUE}).}

\item{invertAuthors}{A boolean value indicating whether the entries provided
by the \code{excludeAuthors} argument should be excluded from network
construction (\code{invertAuthors = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertAuthors = TRUE}).}

\item{invertSources}{A boolean value indicating whether the entries provided
by the \code{excludeSources} argument should be excluded from network
construction (\code{invertSources = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertSources = TRUE}).}

\item{invertSections}{A boolean value indicating whether the entries
provided by the \code{excludeSections} argument should be excluded from
network construction (\code{invertSections = FALSE}) or if they should
be the only values that should be included during network construction
(\code{invertSections = TRUE}).}

\item{invertTypes}{A boolean value indicating whether the entries provided
by the \code{excludeTypes} argument should be excluded from network
construction (\code{invertTypes = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertTypes = TRUE}).}

\item{fileFormat}{An optional file format specification for saving the
backbone results to a file instead of returning an object. Valid values
are \code{"json"}, \code{"xml"}, and \code{NULL} (for returning the results
instead of writing them to a file).}

\item{outfile}{An optional output file name for saving the resulting
network(s) to a file instead of returning an object.}

\item{x}{A \code{"dna_backbone"} object.}

\item{trim}{Number of maximum characters to display in entity labels. Labels
with more characters are truncated, and the last character is replaced by
an asterisk (\code{*}).}

\item{...}{Additional arguments.}

\item{ma}{Number of iterations to compute moving average.}

\item{object}{A \code{"dna_backbone"} object.}

\item{backboneEntities}{A vector of character values to be included in the
backbone. The function will compute the spectral loss between the full
network and the network composed only of those entities on the second mode
that are contained in this vector.}

\item{p}{The penalty parameter. The default value of \code{0} means no
penalty for backbone size is applied.}
}
\value{
A vector with two numeric values: the backbone and redundant loss.
}
\description{
Compute and retrieve the backbone and redundant set of a discourse network.

Compute the backbone loss for any set of entities, for example concepts.
}
\details{
This function applies a simulated annealing algorithm to the discourse
network to partition the set of second-mode entities (e.g., concepts) into a
backbone set and a complementary redundant set.

This function computes the spectral loss for an arbitrary backbone and its
complement, the redundant set, specified by the user. For example, the user
can evaluate how much structure would be lost if the second mode was composed
only of the concepts provided to this function. This can be used to compare
how useful different codebook models are. The penalty parameter \code{p}
applies a penalty factor to the spectral loss. The default value of \code{0}
switches off the penalty.
}
\examples{
\dontrun{
dna_init()
dna_sample()
dna_openDatabase("sample.dna", coderId = 1, coderPassword = "sample")

# compute backbone and redundant set using penalised spectral loss
b <- dna_backbone(method = "penalty",
                  penalty = 3.5,
                  iterations = 10000,
                  variable1 = "organization",
                  variable2 = "concept",
                  qualifier = "agreement",
                  qualifierAggregation = "subtract",
                  normalization = "average")

b # display main results

# extract results from the object
b$backbone # show the set of backbone concepts
b$redundant # show the set of redundant concepts
b$unpenalized_backbone_loss # spectral loss between full and backbone network
b$unpenalized_redundant_loss # spectral loss of redundant network
b$backbone_network # show the backbone network
b$redundant_network # show the redundant network
b$full_network # show the full network

# plot diagnostics with base R
plot(b, ma = 500)

# arrange plots in a 2 x 2 view
par(mfrow = c(2, 2))
plot(b)

# plot diagnostics with ggplot2
library("ggplot2")
p <- autoplot(b)
p

# pick a specific diagnostic
p[[3]]

# use the patchwork package to arrange the diagnostics in a single plot
library("patchwork")
new_plot <- p[[1]] + p[[2]] + p[[3]] + p[[4]]
new_plot & theme_grey() + theme(legend.position = "bottom")

# use the gridExtra package to arrange the diagnostics in a single plot
library("gridExtra")
grid.arrange(p[[1]], p[[2]], p[[3]], p[[4]])

# compute backbone with fixed size (here: 4 concepts)
b <- dna_backbone(method = "fixed",
                  backboneSize = 4,
                  iterations = 2000,
                  variable1 = "organization",
                  variable2 = "concept",
                  qualifier = "agreement",
                  qualifierAggregation = "subtract",
                  normalization = "average")
b

# compute backbone with a nested structure and plot dendrogram
b <- dna_backbone(method = "nested",
                  variable1 = "organization",
                  variable2 = "concept",
                  qualifier = "agreement",
                  qualifierAggregation = "subtract",
                  normalization = "average")
b
plot(b)
autoplot(b)
}

\dontrun{
dna_init()
dna_sample()
dna_openDatabase("sample.dna", coderId = 1, coderPassword = "sample")

dna_evaluateBackboneSolution(
  c("There should be legislation to regulate emissions.",
    "Emissions legislation should regulate CO2.")
)
}

}
\author{
Philip Leifeld, Tim Henrichsen

Philip Leifeld
}
