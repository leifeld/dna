% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dna_polarization.R
\name{dna_polarization}
\alias{dna_polarization}
\alias{autoplot.dna_polarization}
\title{Calculate DNA Polarization}
\usage{
dna_polarization(
  statementType = "DNA Statement",
  variable1 = "organization",
  variable1Document = FALSE,
  variable2 = "concept",
  variable2Document = FALSE,
  qualifier = "agreement",
  duplicates = "include",
  start.date = "01.01.1900",
  stop.date = "31.12.2099",
  timeWindow = "days",
  windowSize = 100,
  kernel = "uniform",
  indentTime = FALSE,
  excludeValues = list(),
  excludeAuthors = character(),
  excludeSources = character(),
  excludeSections = character(),
  excludeTypes = character(),
  algorithm = "greedy",
  normalizeScores = FALSE,
  numClusters = 2,
  numParents = 50,
  numIterations = 1000,
  elitePercentage = 0.1,
  mutationPercentage = 0.1,
  randomSeed = 0
)

\method{autoplot}{dna_polarization}(object, ..., plots = c("hair", "hist", "time_series"))
}
\arguments{
\item{statementType}{The name of the statement type in which the variable
of interest is nested. For example, \code{"DNA Statement"}.}

\item{variable1}{The first variable for network construction. In a one-mode
network, this is the variable for both the rows and columns. In a
two-mode network, this is the variable for the rows only. In an event
list, this variable is only used to check for duplicates (depending on
the setting of the \code{duplicates} argument).}

\item{variable1Document}{A boolean value indicating whether the first
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}).}

\item{variable2}{The second variable for network construction. In a one-mode
network, this is the variable over which the ties are created. For
example, if an organization x organization network is created, and ties
in this network indicate co-reference to a concept, then the second
variable is the \code{"concept"}. In a two-mode network, this is the
variable used for the columns of the network matrix. In an event list,
this variable is only used to check for duplicates (depending on the
setting of the \code{duplicates} argument).}

\item{variable2Document}{A boolean value indicating whether the second
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}}

\item{qualifier}{The qualifier variable. In a one-mode network, this
  variable can be used to count only congruence or conflict ties. For
  example, in an organization x organization network via common concepts,
  a binary \code{"agreement"} qualifier could be used to record only ties
  where both organizations have a positive stance on the concept or where
  both organizations have a negative stance on the concept. With an
  integer qualifier, the tie weight between the organizations would be
  proportional to the similarity or distance between the two organizations
  on the scale of the integer variable. With a short text variable as a
  qualifier, agreement on common categorical values of the qualifier is
  required, for example a tie is established (or a tie weight increased) if
  two actors both refer to the same value on the second variable AND match on
  the categorical qualifier, for example the type of referral.

  In a two-mode network, the qualifier variable can be used to retain only
  positive or only negative statements or subtract negative from positive
  mentions. All of this depends on the setting of the
  \code{qualifierAggregation} argument. For event lists, the qualifier
  variable is only used for filtering out duplicates (depending on the
  setting of the \code{duplicates} argument.

  The qualifier can also be \code{NULL}, in which case it is ignored, meaning
  that values in \code{variable1} and \code{variable2} are unconditionally
  associated with each other in the network when they co-occur. This is
  identical to selecting a qualifier variable and setting
  \code{qualifierAggregation = "ignore"}.}

\item{duplicates}{Setting for excluding duplicate statements before network
construction. Valid settings are \code{"include"} (for including all
statements in network construction), \code{"document"} (for counting
only one identical statement per document), \code{"week"} (for counting
only one identical statement per calendar week), \code{"month"} (for
counting only one identical statement per calendar month), \code{"year"}
(for counting only one identical statement per calendar year), and
\code{"acrossrange"} (for counting only one identical statement across
the whole time range).}

\item{start.date}{The start date for network construction in the format
\code{"dd.mm.yyyy"}. All statements before this date will be excluded.}

\item{stop.date}{The stop date for network construction in the format
\code{"dd.mm.yyyy"}. All statements after this date will be excluded.}

\item{timeWindow}{A character string specifying the time window. Can be
\code{"minutes"}, \code{"hours"}, \code{"days"}, \code{"weeks"},
\code{"months"}, or \code{"years"}, or \code{"no"} for no time window,
in which case a single polarization score is calculated for the entire
timeline.}

\item{windowSize}{An integer specifying the size of the time window. For
example, if the time window is "days" and the window size is \code{22}, the
first time window will be centered around the 12th day of the timeline and
range from the 1st to the 22nd day. The second time window will be centered
around the 13th day and range from the 2nd to the 23rd day, and so on. If
the time window is \code{"no"}, the window size must be \code{0}.}

\item{kernel}{Use kernel smoothing for computing time windows? This option
only matters if the \code{timeWindow} argument has a value other than
\code{"no"} or \code{"event"}. The default value \code{kernel = "no"}
switches off kernel smoothing, which means all statements within a time
window are weighted equally. Other values down-weight statements the
farther they are temporally away from the mid-point of the time window.
Several kernel smoothing functions are available, similar to kernel density
estimation: \code{"uniform"} is similar to \code{"no"} and weights all
statements with a value of \code{0.5}. \code{"gaussian"} uses a standard
normal distribution as a kernel smoother. \code{"epanechnikov"} uses an
Epanechnikov kernel smoother. \code{"triangular"} uses a triangular kernel
function. If in doubt, do not use kernel smoothing.}

\item{indentTime}{If \code{TRUE}, the sequence of time slices under the time
window algorithm starts with the first network and ends with the last
network that are entirely covered within the timeline defined by the start
and stop dates and times. For example, if the start date is 1 February, the
stop date is 31 December, and the time window duration is 21 days, the
mid-point of the first time window will be 11 February (to ensure the first
network entirely fits into the timeline), and the last network will be
centered around 20 December (to ensure the last network entirely fits into
the timeline). If \code{FALSE}, the start and stop dates and times are used
as the first and last mid-points. In that case, the first and last few
networks may contain fewer statements than other time slices and may,
therefore, be more similar to each other.}

\item{excludeValues}{A list of named character vectors that contains entries
which should be excluded during network construction. For example,
\code{list(concept = c("A", "B"), organization = c("org A", "org B"))}
would exclude all statements containing concepts "A" or "B" or
organizations "org A" or "org B" when the network is constructed. This
is irrespective of whether these values appear in \code{variable1},
\code{variable2}, or the \code{qualifier}. Note that only variables at
the statement level can be used here. There are separate arguments for
excluding statements nested in documents with certain meta-data.}

\item{excludeAuthors}{A character vector of authors. If a statement is
nested in a document where one of these authors is set in the "Author"
meta-data field, the statement is excluded from network construction.}

\item{excludeSources}{A character vector of sources. If a statement is
nested in a document where one of these sources is set in the "Source"
meta-data field, the statement is excluded from network construction.}

\item{excludeSections}{A character vector of sections. If a statement is
nested in a document where one of these sections is set in the "Section"
meta-data field, the statement is excluded from network construction.}

\item{excludeTypes}{A character vector of types. If a statement is
nested in a document where one of these types is set in the "Type"
meta-data field, the statement is excluded from network construction.}

\item{algorithm}{The algorithm to compute polarization. Can be "greedy" (for
a greedy algorithm) or "genetic" (for a genetic algorithm).}

\item{normalizeScores}{A logical specifying whether the polarization scores
should be normalized by edge mass per network to take away the effect of
networks over time having different activity levels.}

\item{numClusters}{An integer specifying the number of clusters k. Default is
\code{2}.}

\item{numParents}{Only for the genetic algorithm: An integer specifying the
number of cluster solutions ("parents"). For example, \code{30} or
\code{50}.}

\item{numIterations}{Only for the genetic algorithm: Number of iterations of
the genetic algorithm. Often, \code{50} or \code{100} is enough, but since
there is a built-in convergence check, it is recommended to keep this
number large. The default is \code{1000}.}

\item{elitePercentage}{Only for the genetic algorithm: A double specifying
the percentage of the best solutions that are kept for the next generation.
Useful values range between 0.05 and 0.2.}

\item{mutationPercentage}{Only for the genetic algorithm: A double specifying
the percentage of the solutions that are mutated. Useful values range
between 0.05 and 0.2.}

\item{randomSeed}{Only for the genetic algorithm: An integer specifying the
random seed for reproducibility of exact findings. The default is \code{0},
which means the algorithm generates the random seed (= no reproducibility).}

\item{object}{An object of class `dna_polarization`.}

\item{...}{Additional arguments passed to the plotting functions.
Currently not used.}

\item{plots}{A character vector specifying the types of plots to generate.
Options are "hair", "hist", and "time_series". The hair plot
shows the convergence of the maximal polarization over time.
The histogram plot shows the distribution of the number of
iterations until convergence. The time series plot shows the
polarization over time.}
}
\value{
An object representing the polarization of actors and the results of
  the algorithm for all time steps and iterations.

A list of ggplot objects corresponding to the specified plots.
}
\description{
This function calculates the polarization scores for a single network or a
(kernel-smoothed) series of time windows.

This function generates various plots for a DNA polarization object.
}
\examples{
\dontrun{
library("ggplot2")
dna_init()
dna_sample()
dna_openDatabase("sample.dna", coderId = 1, coderPassword = "sample")

p <- dna_polarization(timeWindow = "days",
                      windowSize = 8,
                      kernel = "gaussian",
                      normalizeScores = FALSE)
str(p)
autoplot(p)

p2 <- dna_polarization(timeWindow = "no",
                       normalizeScores = TRUE,
                       algorithm = "genetic")
p2$finalMaxQs # polarization between 0 and 1
}

}
\author{
Philip Leifeld
}
