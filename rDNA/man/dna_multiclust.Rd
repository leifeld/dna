% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rDNA.R
\name{dna_multiclust}
\alias{dna_multiclust}
\title{Compute multiple cluster solutions for a discourse network}
\usage{
dna_multiclust(
  connection,
  statementType = "DNA Statement",
  variable1 = "organization",
  variable1Document = FALSE,
  variable2 = "concept",
  variable2Document = FALSE,
  qualifier = "agreement",
  duplicates = "include",
  start.date = "01.01.1900",
  stop.date = "31.12.2099",
  start.time = "00:00:00",
  stop.time = "23:59:59",
  timewindow = "no",
  windowsize = 100,
  excludeValues = list(),
  excludeAuthors = character(),
  excludeSources = character(),
  excludeSections = character(),
  excludeTypes = character(),
  invertValues = FALSE,
  invertAuthors = FALSE,
  invertSources = FALSE,
  invertSections = FALSE,
  invertTypes = FALSE,
  saveObjects = FALSE,
  k = 0,
  k.max = 5,
  single = TRUE,
  average = TRUE,
  complete = TRUE,
  ward = TRUE,
  kmeans = TRUE,
  pam = TRUE,
  equivalence = TRUE,
  concor_one = TRUE,
  concor_two = TRUE,
  louvain = TRUE,
  fastgreedy = TRUE,
  walktrap = TRUE,
  leading_eigen = TRUE,
  edge_betweenness = FALSE,
  infomap = TRUE,
  label_prop = TRUE,
  spinglass = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{connection}{A \code{dna_connection} object created by the
\code{dna_connection} function.}

\item{statementType}{The name of the statement type in which the variable
of interest is nested. For example, \code{"DNA Statement"}.}

\item{variable1}{The first variable for network construction. In a one-mode
network, this is the variable for both the rows and columns. In a
two-mode network, this is the variable for the rows only. In an event
list, this variable is only used to check for duplicates (depending on
the setting of the \code{duplicate} argument).}

\item{variable1Document}{A boolean value indicating whether the first
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}).}

\item{variable2}{The second variable for network construction. In a one-mode
network, this is the variable over which the ties are created. For
example, if an organization x organization network is created, and ties
in this network indicate co-reference to a concept, then the second
variable is the \code{"concept"}. In a two-mode network, this is the
variable used for the columns of the network matrix. In an event list,
this variable is only used to check for duplicates (depending on the
setting of the \code{duplicate} argument).}

\item{variable2Document}{A boolean value indicating whether the second
variable is at the document level (i.e., \code{"author"},
\code{"source"}, \code{"section"}, \code{"type"}, \code{"id"}, or
\code{"title"}}

\item{qualifier}{The qualifier variable. In a one-mode network, this
  variable can be used to count only congruence or conflict ties. For
  example, in an organization x organization network via common concepts,
  a binary \code{"agreement"} qualifier could be used to record only ties
  where both organizations have a positive stance on the concept or where
  both organizations have a negative stance on the concept. With an
  integer qualifier, the tie weight between the organizations would be
  proportional to the similarity or distance between the two organizations
  on the scale of the integer variable.

  In a two-mode network, the qualifier variable can be used to retain only
  positive or only negative statements or subtract negative from positive
  mentions. All of this depends on the setting of the
  \code{qualifierAggregation} argument. For event lists, the qualifier
  variable is only used for filtering out duplicates (depending on the
  setting of the \code{duplicate} argument.

  The qualifier can also be \code{NULL}, in which case it is ignored, meaning
  that values in \code{variable1} and \code{variable2} are unconditionally
  associated with each other in the network when they co-occur. This is
  identical to selecting a qualifier variable and setting
  \code{qualifierAggregation = "ignore"}.}

\item{duplicates}{Setting for excluding duplicate statements before network
construction. Valid settings are \code{"include"} (for including all
statements in network construction), \code{"document"} (for counting
only one identical statement per document), \code{"week"} (for counting
only one identical statement per calendar week), \code{"month"} (for
counting only one identical statement per calendar month), \code{"year"}
(for counting only one identical statement per calendar year), and
\code{"acrossrange"} (for counting only one identical statement across
the whole time range).}

\item{start.date}{The start date for network construction in the format
"dd.mm.yyyy". All statements before this date will be excluded.}

\item{stop.date}{The stop date for network construction in the format
"dd.mm.yyyy". All statements after this date will be excluded.}

\item{start.time}{The start time for network construction on the specified
\code{start.date}. All statements before this time on the specified date
will be excluded.}

\item{stop.time}{The stop time for network construction on the specified
\code{stop.date}. All statements after this time on the specified date
will be excluded.}

\item{timewindow}{Possible values are \code{"no"}, \code{"events"},
\code{"seconds"}, \code{"minutes"}, \code{"hours"}, \code{"days"},
\code{"weeks"}, \code{"months"}, and \code{"years"}. If \code{"no"} is
selected (= the default setting), no time window will be used. If any of
the time units is selected, a moving time window will be imposed, and
only the statements falling within the time period defined by the window
will be used to create the network. The time window will then be moved
forward by one time unit at a time, and a new network with the new time
boundaries will be created. This is repeated until the end of the overall
time span is reached. All time windows will be saved as separate
networks in a list. The duration of each time window is defined by the
\code{windowsize} argument. For example, this could be used to create a
time window of 6 months which moves forward by one month each time, thus
creating time windows that overlap by five months. If \code{"events"} is
used instead of a natural time unit, the time window will comprise
exactly as many statements as defined in the \code{windowsize} argument.
However, if the start or end statement falls on a date and time where
multiple events happen, those additional events that occur simultaneously
are included because there is no other way to decide which of the
statements should be selected. Therefore the window size is sometimes
extended when the start or end point of a time window is ambiguous in
event time.}

\item{windowsize}{The number of time units of which a moving time window is
comprised. This can be the number of statement events, the number of days
etc., as defined in the \code{"timewindow"} argument.}

\item{excludeValues}{A list of named character vectors that contains entries
which should be excluded during network construction. For example,
\code{list(concept = c("A", "B"), organization = c("org A", "org B"))}
would exclude all statements containing concepts "A" or "B" or
organizations "org A" or "org B" when the network is constructed. This
is irrespective of whether these values appear in \code{variable1},
\code{variable2}, or the \code{qualifier}. Note that only variables at
the statement level can be used here. There are separate arguments for
excluding statements nested in documents with certain meta-data.}

\item{excludeAuthors}{A character vector of authors. If a statement is
nested in a document where one of these authors is set in the "Author"
meta-data field, the statement is excluded from network construction.}

\item{excludeSources}{A character vector of sources. If a statement is
nested in a document where one of these sources is set in the "Source"
meta-data field, the statement is excluded from network construction.}

\item{excludeSections}{A character vector of sections. If a statement is
nested in a document where one of these sections is set in the "Section"
meta-data field, the statement is excluded from network construction.}

\item{excludeTypes}{A character vector of types. If a statement is
nested in a document where one of these types is set in the "Type"
meta-data field, the statement is excluded from network construction.}

\item{invertValues}{A boolean value indicating whether the entries provided
by the \code{excludeValues} argument should be excluded from network
construction (\code{invertValues = FALSE}) or if they should be the only
values that should be included during network construction
(\code{invertValues = TRUE}).}

\item{invertAuthors}{A boolean value indicating whether the entries provided
by the \code{excludeAuthors} argument should be excluded from network
construction (\code{invertAuthors = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertAuthors = TRUE}).}

\item{invertSources}{A boolean value indicating whether the entries provided
by the \code{excludeSources} argument should be excluded from network
construction (\code{invertSources = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertSources = TRUE}).}

\item{invertSections}{A boolean value indicating whether the entries
provided by the \code{excludeSections} argument should be excluded from
network construction (\code{invertSections = FALSE}) or if they should
be the only values that should be included during network construction
(\code{invertSections = TRUE}).}

\item{invertTypes}{A boolean value indicating whether the entries provided
by the \code{excludeTypes} argument should be excluded from network
construction (\code{invertTypes = FALSE}) or if they should be the
only values that should be included during network construction
(\code{invertTypes = TRUE}).}

\item{saveObjects}{Store the original output of the respective clustering
method in the \code{cl} slot of the return object? If \code{TRUE}, one
cluster object per time point will be saved, for all time points for which
network data are available. At each time point, only the cluster object
with the highest modularity score will be saved, all others discarded. The
\code{max_mod} slot of the object contains additional information on which
measure was saved at each time point and what the corresponding modularity
score is.}

\item{k}{The number of clusters to compute. This constrains the choice of
clustering methods because some methods require a predefined \code{k} while
other methods do not. To permit arbitrary numbers of clusters, depending on
the respective algorithm (or the value of modularity in some cases), choose
\code{k = 0}. This corresponds to the theoretical notion of
"multipolarization". For "bipolarization", choose \code{k = 2} in order to
constrain the cluster solutions to exactly two groups.}

\item{k.max}{If \code{k = 0}, there can be arbitrary numbers of clusters. In
this case, \code{k.max} sets the maximal number of clusters that can be
identified.}

\item{single}{Include hierarchical clustering with single linkage in the pool
of clustering methods? The \code{\link[stats]{hclust}} function from
the \pkg{stats} package is applied to Jaccard distances in the affiliation
network for this purpose. Only valid if \code{k > 1}.}

\item{average}{Include hierarchical clustering with average linkage in the
pool of clustering methods? The \code{\link[stats]{hclust}} function from
the \pkg{stats} package is applied to Jaccard distances in the affiliation
network for this purpose. Only valid if \code{k > 1}.}

\item{complete}{Include hierarchical clustering with complete linkage in the
pool of clustering methods? The \code{\link[stats]{hclust}} function from
the \pkg{stats} package is applied to Jaccard distances in the affiliation
network for this purpose. Only valid if \code{k > 1}.}

\item{ward}{Include hierarchical clustering with Ward's algorithm in the
pool of clustering methods? The \code{\link[stats]{hclust}} function from
the \pkg{stats} package is applied to Jaccard distances in the affiliation
network for this purpose. If \code{k = 0} is selected, different solutions
with varying \code{k} are attempted, and the solution with the highest
modularity is retained.}

\item{kmeans}{Include k-means clustering in the pool of clustering methods?
The \code{\link[stats]{kmeans}} function from the \pkg{stats} package is
applied to Jaccard distances in the affiliation network for this purpose.
If \code{k = 0} is selected, different solutions with varying \code{k} are
attempted, and the solution with the highest modularity is retained.}

\item{pam}{Include partitioning around medoids in the pool of clustering
methods? The \code{\link[cluster]{pam}} function from the \pkg{cluster}
package is applied to Jaccard distances in the affiliation network for this
purpose. If \code{k = 0} is selected, different solutions with varying
\code{k} are attempted, and the solution with the highest modularity is
retained.}

\item{equivalence}{Include equivalence clustering (as implemented in the
\code{\link[sna]{equiv.clust}} function in the \pkg{sna} package), based on
shortest path distances between nodes (as implemented in the
\code{\link[sna]{sedist}} function in the \pkg{sna} package) in the
positive subtract network? If \code{k = 0} is selected, different solutions
with varying \code{k} are attempted, and the solution with the highest
modularity is retained.}

\item{concor_one}{Include CONvergence of iterative CORrelations (CONCOR) in
the pool of clustering methods? The algorithm is applied to the positive
subtract network to identify \code{k = 2} clusters. The method is omitted
if \code{k != 2}.}

\item{concor_two}{Include CONvergence of iterative CORrelations (CONCOR) in
the pool of clustering methods? The algorithm is applied to the affiliation
network to identify \code{k = 2} clusters. The method is omitted
if \code{k != 2}.}

\item{louvain}{Include the Louvain community detection algorithm in the pool
of clustering methods? The \code{\link[igraph]{cluster_louvain}} function
in the \pkg{igraph} package is applied to the positive subtract network for
this purpose.}

\item{fastgreedy}{Include the fast and greedy community detection algorithm
in the pool of clustering methods? The
\code{\link[igraph]{cluster_fast_greedy}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose.}

\item{walktrap}{Include the Walktrap community detection algorithm
in the pool of clustering methods? The
\code{\link[igraph]{cluster_walktrap}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose.}

\item{leading_eigen}{Include the leading eigenvector community detection
algorithm in the pool of clustering methods? The
\code{\link[igraph]{cluster_leading_eigen}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose.}

\item{edge_betweenness}{Include the edge betweenness community detection
algorithm by Girvan and Newman in the pool of clustering methods? The
\code{\link[igraph]{cluster_edge_betweenness}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose. Note
that this method is disabled by default because there is a
non-deterministic bug in the implementation, which sometimes leads the \R
session to abort; see \url{https://github.com/igraph/rigraph/issues/336}
(as of 15 April 2019).}

\item{infomap}{Include the infomap community detection algorithm
in the pool of clustering methods? The
\code{\link[igraph]{cluster_infomap}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose.}

\item{label_prop}{Include the label propagation community detection algorithm
in the pool of clustering methods? The
\code{\link[igraph]{cluster_label_prop}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose.}

\item{spinglass}{Include the spinglass community detection algorithm
in the pool of clustering methods? The
\code{\link[igraph]{cluster_spinglass}} function in the \pkg{igraph}
package is applied to the positive subtract network for this purpose. Note
that this method is disabled by default because it is relatively slow.}

\item{verbose}{A boolean value indicating whether details of network
construction should be printed to the R console.}
}
\value{
The function creates a \code{dna_multiclust} object, which contains
  the following items:
\describe{
  \item{k}{The number of clusters determined by the user.}
  \item{cl}{Cluster objects returned by the respective cluster function. If
    multiple methods are used, this returns the object with the highest
    modularity.}
  \item{max_mod}{A data frame with one row per time point (that is, only one
    row in the default case and multiple rows if time windows are used) and
    the maximal modularity for the given time point across all cluster
    methods.}
  \item{modularity}{A data frame with the modularity values for all separate
    cluster methods and all time points.}
  \item{membership}{A large data frame with all nodes' membership information
    for each time point and each clustering method.}
}
}
\description{
Compute multiple cluster solutions for a discourse network.
}
\details{
This function applies a number of different graph clustering techniques to
a discourse network dataset. The user provides a \link{dna_connection}
object, along with many of the same arguments as in the \link{dna_network}
function, and a few additional arguments that determine which kinds of
clustering methods should be used and how. In particular, the \code{k}
argument can be \code{0} (for arbitrary numbers of clusters) or any positive
integer value (e.g., \code{2}, for constraining the number of clusters to
exactly \code{k} groups). This is useful for assessing the polarization of a
discourse network.

In particular, the function can be used to compute the maximal modularity of
a smoothed time series of discourse networks using the \code{timewindow} and
\code{windowsize} arguments for a given \code{k} across a number of
clustering methods. The resulting smoothed time series of bipolarization or
multipolarization values can be plotted using the \link{dna_plotModularity}
function.

The \code{dna_multiclust} function replaces the \code{dna_timeWindow}
function that was present in earlier versions of the \pkg{rDNA} package. In
order to generate bipolarization measures, use \code{k = 2}. For
multipolarization, use \code{k = 0}.

It is also possible to switch off all but one clustering method using the
respective arguments and carry out a simple cluster analysis with the method
of choice for a certain time span of the discourse network, without any time
window options.
}
\examples{
library("rDNA")
dna_init()
samp <- dna_sample()
conn <- dna_connection(samp)

# example 1: compute 12 cluster solutions for one time point
mc1 <- dna_multiclust(connection = conn,
                      variable1 = "organization",
                      variable2 = "concept",
                      qualifier = "agreement",
                      duplicates = "document",
                      k = 0,                # flexible numbers of clusters
                      saveObjects = TRUE)   # retain hclust object

mc1$modularity      # return modularity scores for 12 clustering methods
mc1$max_mod         # return the maximal value of the 12, along with dates
mc1$memberships     # return cluster memberships for all 12 cluster methods
plot(mc1$cl[[1]])   # plot hclust dendrogram

# example 2: compute only Girvan-Newman edge betweenness with two clusters
set.seed(12345)
mc2 <- dna_multiclust(connection = conn,
                      k = 2,
                      single = FALSE,
                      average = FALSE,
                      complete = FALSE,
                      ward = FALSE,
                      kmeans = FALSE,
                      pam = FALSE,
                      equivalence = FALSE,
                      concor_one = FALSE,
                      concor_two = FALSE,
                      louvain = FALSE,
                      fastgreedy = FALSE,
                      walktrap = FALSE,
                      leading_eigen = FALSE,
                      edge_betweenness = TRUE,
                      infomap = FALSE,
                      label_prop = FALSE,
                      spinglass = FALSE)
mc2$memberships  # return membership in two clusters
mc2$modularity   # return modularity of the cluster solution

# example 3: smoothed bipolarization using time window algorithm
mc3 <- dna_multiclust(connection = conn,
                      k = 2,
                      timewindow = "events",
                      windowsize = 28)
mc3$max_mod              # maximal modularity and method per time point
dna_plotModularity(mc3)  # smoothed polarization curve (toy example)
dna_plotModularity(mc3, only.max = FALSE)  # separately for all methods
dna_plotModularity(mc3, anomalize = TRUE)  # anomaly detection

}
\seealso{
\code{\link{print.dna_multiclust}}, \code{\link{dna_plotModularity}}
}
\author{
Philip Leifeld
}
